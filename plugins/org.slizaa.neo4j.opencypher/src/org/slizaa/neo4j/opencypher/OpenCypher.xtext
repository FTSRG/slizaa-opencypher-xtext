grammar org.slizaa.neo4j.opencypher.OpenCypher hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate openCypher "http://www.slizaa.org/neo4j/opencypher/OpenCypher"

Cypher:
/*
 * cypher : ws allOptions statement ws ';'? ws ;
 */
	{Cypher} options=AllOptions statement=Statement ';'?;

AllOptions:
/*
 * allOptions : ( anyCypherOption ws )* ;
 * anyCypherOption : cypherOption
 *              | explain
 *              | profile;
 * explain : EXPLAIN ;
 * profile : PROFILE ;
 */
	{AllOptions} (explain?='EXPLAIN'? & profile?='PROFILE'? & cypherOption+=CypherOption*);

CypherOption:
/*
 * cypherOption : CYPHER ( sp versionNumber )? ( sp configurationOption )* ;
 */
	{CypherOption} 'CYPHER' (versionNumber=VersionNumber)? (configurationOption+=ConfigurationOption)*;

VersionNumber:
/*
 * versionNumber : digitString '.' digitString ;
 */
	versionNumber=Number;

ConfigurationOption:
/*
 * configurationOption : symbolicNameString ws '=' ws symbolicNameString ;
 */
	key=SYMBOLIC_NAME_STRING '=' value=SYMBOLIC_NAME_STRING;

Statement:
/*
 * statement : command
 *           | query;
 */
	Command | Query;

Query:
/*
 * query : regularQuery
 *       | bulkImportQuery;
 */
	RegularQuery | BulkImportQuery;

RegularQuery:
/*
 * regularQuery : singleQuery ( ws union )* ;
 */
	SingleQuery ({RegularQuery.singleQuery=current} union+=Union)*;

BulkImportQuery:
/*
 * bulkImportQuery : periodicCommitHint ws loadCSVQuery ;
 */
	periodicCommitHint=PeriodicCommitHint loadCSVQuery=LoadCSVQuery;

SingleQuery:
/*
 * singleQuery : clause ( ws clause )* ;
 */
	clauses+=Clause (clauses+=Clause)*;

PeriodicCommitHint:
/*
 * periodicCommitHint : USING sp PERIODIC sp COMMIT ( sp signedIntegerLiteral )? ;
 */
	{PeriodicCommitHint} 'USING' 'PERIODIC' 'COMMIT' numberOfRowsPerCommit=Number?;

LoadCSVQuery:
/*
 * loadCSVQuery : loadCSV ( ws clause )* ;
 */
	loadCSV=LoadCSV (clauses+=Clause)*;

Union:
/*
 * union : ( UNION sp ALL singleQuery )
 *  | ( UNION singleQuery );
 */
	('UNION' all?='ALL'? singleQuery=SingleQuery);

Clause:
/*
 * clause : loadCSV
 *        | start
 *        | match
 *        | unwind
 *        | merge
 *        | create
 *        | setClause
 *        | delete
 *        | remove
 *        | foreach
 *        | with
 *        | return
 *       ;
 */
	LoadCSV | Start | Match | Unwind | Merge | Create | SetClause | Delete | Remove | Foreach | With | Return;

Command:
/*
 * command : createUniqueConstraint
 *         | createNodePropertyExistenceConstraint
 *         | createRelationshipPropertyExistenceConstraint
 *         | createIndex
 *         | dropUniqueConstraint
 *         | dropNodePropertyExistenceConstraint
 *         | dropRelationshipPropertyExistenceConstraint
 *         | dropIndex
 *      ;
 */
	CreateUniqueConstraint | CreateNodePropertyExistenceConstraint | CreateRelationshipPropertyExistenceConstraint |
	CreateIndex | DropUniqueConstraint | DropNodePropertyExistenceConstraint |
	DropRelationshipPropertyExistenceConstraint | DropIndex;

CreateUniqueConstraint:
/*
 * createUniqueConstraint : CREATE ws uniqueConstraintSyntax ;
 */
	'CREATE' UniqueConstraintSyntax;

CreateNodePropertyExistenceConstraint:
/*
 * createNodePropertyExistenceConstraint : CREATE ws nodePropertyExistenceConstraintSyntax ;
 */
	'CREATE' NodePropertyExistenceConstraintSyntax;

CreateRelationshipPropertyExistenceConstraint:
/*
 * createRelationshipPropertyExistenceConstraint : CREATE ws relationshipPropertyExistenceConstraintSyntax ;
 */
	'CREATE' RelationshipPropertyExistenceConstraintSyntax;

CreateIndex:
/*
 * createIndex : CREATE sp INDEX sp ON ws nodeLabel '(' propertyKeyName ')' ;
 */
	'CREATE' 'INDEX' 'ON' nodeLabel=NodeLabel '(' propertyKeyName=PropertyKeyName ')';

DropUniqueConstraint:
/*
 * dropUniqueConstraint : DROP sp uniqueConstraintSyntax ;
 */
	'DROP' uniqueConstraint=UniqueConstraintSyntax;

DropNodePropertyExistenceConstraint:
/*
 * dropNodePropertyExistenceConstraint : DROP sp nodePropertyExistenceConstraintSyntax ;
 */
	'DROP' nodePropertyExistenceConstraint=NodePropertyExistenceConstraintSyntax;

DropRelationshipPropertyExistenceConstraint:
/*
 * dropRelationshipPropertyExistenceConstraint : DROP sp relationshipPropertyExistenceConstraintSyntax ;
 */
	'DROP' relationshipPropertyExistenceConstraint=RelationshipPropertyExistenceConstraintSyntax;

DropIndex:
/*
 * dropIndex : DROP sp INDEX sp ON ws nodeLabel '(' propertyKeyName ')' ;
 */
	'DROP' 'INDEX' 'ON' nodeLabel=NodeLabel '(' propertyKeyName=PropertyKeyName ')';

UniqueConstraintSyntax:
/*
 * uniqueConstraintSyntax : CONSTRAINT sp ON ws '(' variable nodeLabel ')' ASSERT propertyExpression IS sp UNIQUE ;
 */
	'CONSTRAINT' 'ON' '(' variable=Variable nodeLabel=NodeLabel ')' 'ASSERT' propertyExpression=PropertyExpression 'IS'
	'UNIQUE';

NodePropertyExistenceConstraintSyntax:
/*
 * nodePropertyExistenceConstraintSyntax : CONSTRAINT sp ON ws '(' variable nodeLabel ')' ASSERT sp EXISTS '(' propertyExpression ')' ;
 */
	'CONSTRAINT' 'ON' '(' variable=Variable nodeLabel=NodeLabel ')' 'ASSERT' 'EXISTS' '('
	propertyExpression=PropertyExpression ')';

RelationshipPropertyExistenceConstraintSyntax:
/*
 * relationshipPropertyExistenceConstraintSyntax : CONSTRAINT sp ON ws relationshipPatternSyntax ASSERT sp EXISTS '(' propertyExpression ')' ;
 */
	'CONSTRAINT' 'ON' relationshipPattern=RelationshipPatternSyntax 'ASSERT' 'EXISTS' '('
	propertyExpression=PropertyExpression ')';

RelationshipPatternSyntax:
/*
 * relationshipPatternSyntax : ( '(' ws ')' dash '[' variable relType ']' dash '(' ws ')' )
 *                           | ( '(' ws ')' dash '[' variable relType ']' rightArrowHead dash '(' ws ')' )
 *                           | ( '(' ws ')' leftArrowHead dash '[' variable relType ']' dash '(' ws ')' );
 */
	('(' ')' incoming?=LeftArrowHead? Dash '[' variable=Variable relType=RelType ']' Dash outgoing?=RightArrowHead? '('
	')');

LoadCSV:
/*
 * loadCSV : LOAD sp CSV sp ( WITH sp HEADERS sp )? FROM sp expression sp AS sp variable sp ( FIELDTERMINATOR sp StringLiteral )? ;
 */
	{LoadCSV} 'LOAD' 'CSV' withHeaders?=LoadCSVWithHeaders? 'FROM' expression=Expression 'AS' variable=Variable
	('FIELDTERMINATOR' fieldterminator=STRING_LITERAL)?;

Match:
/*
 * match : ( OPTIONAL sp )? MATCH ws pattern ws ( hint )* where? ;
 */
	optional?='OPTIONAL'? 'MATCH' pattern=Pattern (hints+=Hint)* where=Where?;

Unwind:
/*
 * unwind : UNWIND ws expression sp AS sp variable ;
 */
	'UNWIND' expression=Expression 'AS' variable=Variable;

Merge:
/*
 * merge : MERGE ws patternPart ( sp mergeAction )* ;
 */
	'MERGE' patternPart=PatternPart (mergeActions+=MergeAction)*;

MergeAction:
/*
 * mergeAction : ( ON sp MATCH sp setClause )
 *             | ( ON sp CREATE sp setClause );
 */
	'ON' action=('MATCH' | 'CREATE') setClause=SetClause;

Create:
/*
 * create : ( CREATE sp UNIQUE ws pattern )
 *        | ( CREATE ws pattern );
 */
	'CREATE' unique?='UNIQUE'? pattern=Pattern;

SetClause:
/*
 * setClause : SET setItem ( ',' setItem )* ;
 */
	'SET' setItems+=SetItem (',' setItems+=SetItem)*;

SetItem:
/*
 * setItem : ( propertyExpression '=' expression )
 *         | ( variable '=' expression )
 *         | ( variable '+=' expression )
 *         | ( variable nodeLabels );
 */
	(propertyExpression=PropertyExpression '=' expression=Expression) | (variable=Variable '=' expression=Expression) |
	(variable=Variable '+=' expression=Expression) | (variable=Variable nodeLabels=NodeLabels);

Delete:
/*
 * delete : ( DELETE expression ( ',' expression )* )
 *        | ( DETACH sp DELETE expression ( ',' expression )* );
 */
	(detach?='DETACH')? 'DELETE' expressions+=Expression (',' expressions+=Expression)*;

Remove:
/*
 * remove : REMOVE sp removeItem ( ws ',' ws removeItem )* ;
 */
	'REMOVE' removeItems+=RemoveItem (',' removeItems+=RemoveItem)*;

RemoveItem:
/*
 * removeItem : ( variable nodeLabels )
 *              | propertyExpression;
 */
	(variable=Variable nodeLabels=NodeLabels) | PropertyExpression;

Foreach:
/*
 * foreach : FOREACH ws '(' ws variable sp IN sp expression '|' ( sp clause )+ ws ')' ;
 */
	'FOREACH' '(' variable=Variable 'IN' expression=Expression '|' (clause+=Clause)+ ')';

With:
/*
 * with : ( WITH DISTINCT sp returnBody where? )
 *      | ( WITH sp returnBody where? );
 */
	'WITH' distint?='DISTINCT'? returnBody=ReturnBody where=Where?;

Return:
/*
 * return : ( RETURN sp DISTINCT sp returnBody )
 *        | ( RETURN sp returnBody );
 */
	(return='RETURN' distinct?='DISTINCT'? body=ReturnBody);

ReturnBody:
/*
 * returnBody : returnItems ( sp order )? ( sp skip )? ( sp limit )? ;
 */
	ReturnItems (order=Order)? (skip=Skip)? (limit=Limit)?;

ReturnItems:
/*
 * returnItems : ( '*' ( ws ',' ws returnItem )* )
 *             | ( returnItem ( ws ',' ws returnItem )* );
 */
	{ReturnItems} (all='*' (',' items+=ReturnItem)*) | (items+=ReturnItem (',' items+=ReturnItem)*);

ReturnItem:
/*
 * returnItem : ( expression sp AS sp variable )
 *              | expression;
 */
	expression=Expression ('AS' alias=Variable)?;

Order:
/*
 * order : ORDER sp BY sp sortItem ( ',' ws sortItem )* ;
 */
	'ORDER' 'BY' orderBy+=SortItem (',' orderBy+=SortItem)*;

Skip:
/*
 * skip: L_SKIP sp expression;
 */
	'SKIP' skip=Expression;

Limit:
/*
 * limit: LIMIT sp expression;
 */
	'LIMIT' limit=Expression;

SortItem:
/*
 * sortItem : ( expression ( DESCENDING | DESC ) )
 *          | ( expression ( ASCENDING | ASC )? );
 */
	(expression=Expression sort=('DESCENDING' | 'DESC' | 'ASCENDING' | 'ASC')?);

Hint hidden():
/*
 * hint : ( USING sp INDEX sp variable nodeLabel '(' propertyKeyName ')' )
 *      | ( USING sp JOIN sp ON sp variable ( ws ',' ws variable )* )
 *      | ( USING sp SCAN sp variable nodeLabel );
 */
	{IndexHint} 'USING' WS 'INDEX' WS variable=Variable nodeLabel=NodeLabel WS '(' propertyKeyName=PropertyKeyName ')' |
	{JoinHint} ('USING' WS 'JOIN' WS 'ON' variables+=Variable (',' variables+=Variable)*) | {ScanHint} ('USING' WS 'SCAN'
	WS variable=Variable nodeLabel=NodeLabel);

Start:
/*
 * start : START sp startPoint ( ws ',' ws startPoint )* where?;
 */
	'START' startPoint+=StartPoint (',' startPoint+=StartPoint)* where=Where?;

StartPoint:
/*
 * startPoint : variable ws '=' ws lookup;
 */
	variable=Variable '=' lookup=Lookup;

Lookup:
/*
 * lookup : nodeLookup
 *        | relationshipLookup;
 */
	NodeLookup | RelationshipLookup;

NodeLookup:
/*
 * nodeLookup : NODE ( identifiedIndexLookup | indexQuery | idLookup ) ;
 */
	'NODE' (IdentifiedIndexLookup | IndexQuery | IdLookup);

RelationshipLookup:
/*
 * relationshipLookup : ( RELATIONSHIP | REL ) ( identifiedIndexLookup | indexQuery | idLookup ) ;
 */
	('RELATIONSHIP' | 'REL') (IdentifiedIndexLookup | IndexQuery | IdLookup);

IdentifiedIndexLookup:
/*
 * identifiedIndexLookup : ':' symbolicNameString '(' symbolicNameString '=' ( StringLiteral | parameter ) ')' ; 
 */
	':' indexName=SYMBOLIC_NAME_STRING '(' key=SYMBOLIC_NAME_STRING '=' (value=STRING_LITERAL | parameter=Parameter) ')';

IndexQuery:
/*
 * indexQuery : ':' symbolicNameString '(' ( StringLiteral | parameter ) ')' ;
 */
	':' indexName=SYMBOLIC_NAME_STRING '(' (query=STRING_LITERAL | parameter=Parameter) ')';

IdLookup:
/*
 * idLookup : '(' ( literalIds | parameter | '*' ) ')' ;
 */
	'(' (ids=LiteralIds | parameter=Parameter | wildcard='*') ')';

LiteralIds:
/*
 * literalIds : unsignedIntegerLiteral ( ws ',' ws unsignedIntegerLiteral )*;
 */
// TODO:unsignedIntegerLiteral
	ids+=Number (',' ids+=Number)*;

Where:
/*
 * where : WHERE sp expression;
 */
	'WHERE' expression=Expression;

Pattern:
/*
 * pattern : patternPart ( ',' patternPart )*;
 */
	patterns+=PatternPart (',' patterns+=PatternPart)*;

PatternPart:
/*
 * patternPart : ( variable ws '=' ws anonymousPatternPart )
 *               | anonymousPatternPart;
 */
	(var=Variable '=' part=AnonymousPatternPart) | AnonymousPatternPart;

AnonymousPatternPart:
/*
 * anonymousPatternPart : shortestPathPattern
 *                      | patternElement;
 */
	ShortestPathPattern | PatternElement;

ShortestPathPattern:
/*
 * shortestPathPattern : ( SHORTESTPATH '(' patternElement ')' )
 *                     | ( ALLSHORTESTPATHS '(' patternElement ')' );
 */
	{ShortestPath} 'SHORTESTPATH' '(' patternElement=PatternElement ')' | {AllShortestPath} 'ALLSHORTESTPATHS' '('
	patternElement=PatternElement ')';

PatternElement:
/*
 * patternElement : ( nodePattern ( ws patternElementChain )* )
 *                | ( '(' patternElement ')' )
 */
	(nodepattern=NodePattern (chain+=PatternElementChain)*) | '(' PatternElement ')';

NodePattern:
/*
 * nodePattern : '(' ws ( variable ws )? nodeLabels? properties? ws ')' ;
 */
	{NodePattern} '(' variable=Variable? nodeLabels=NodeLabels? properties=Properties? ')';

PatternElementChain:
/*
 * patternElementChain : relationshipPattern ws nodePattern ;
 */
	relationshipPattern=RelationshipPattern nodePattern=NodePattern;

RelationshipPattern:
/*
 * relationshipPattern : ( ws leftArrowHead ws dash ws relationshipDetail? ws dash ws rightArrowHead )
 *                     | ( ws leftArrowHead ws dash ws relationshipDetail? ws dash )
 *                     | ( ws dash ws relationshipDetail? ws dash ws rightArrowHead )
 *                     | ( ws dash ws relationshipDetail? ws dash );
 */
	{RelationshipPattern} (incoming?=LeftArrowHead? Dash detail=RelationshipDetail? Dash outgoing?=RightArrowHead?);

RelationshipDetail:
/*
 * relationshipDetail : '[' variable? '?'? relationshipTypes? ( '*' rangeLiteral? )? properties? ']' ;
 */
	{RelationshipDetail} '[' variable=Variable? optional?='?'? types=RelationshipTypes? (range=RangeLiteral)?
	properties=Properties? ']';

Properties:
/*
 * properties : mapLiteral
 *            | parameter;
 */
	MapLiteral | Parameter;

RelType:
/*
 * relType : ':' relTypeName ;
 */
	':' RelTypeName;

RelationshipTypes:
/*
 * relationshipTypes : ':' relTypeName ( ws '|' ':'? ws relTypeName )* ;
 */
	':' relTypeName+=RelTypeName ('|' ':'? relTypeName+=RelTypeName)*;

NodeLabels:
/*
 * nodeLabels : nodeLabel ( ws nodeLabel )* ;
 */
	nodeLabels+=NodeLabel (nodeLabels+=NodeLabel)*;

NodeLabel:
/*
 * nodeLabel : ':' labelName ;
 */
	':' labelName=LabelName;

RangeLiteral:
// TODO: CHECK - Number (positive Integer)
/*
 * rangeLiteral : ( unsignedIntegerLiteral ws )? '..' ( ws unsignedIntegerLiteral )? ;
 */
	{RangeLiteral} '*' (lower=Number? '..' upper=Number?)?;

LabelName:
/*
 * labelName : symbolicNameString ;
 */
	SYMBOLIC_NAME_STRING_X;

RelTypeName:
/*
 * relTypeName : symbolicNameString ;
 */
	SYMBOLIC_NAME_STRING_X;

Expression:
/*
 * expression : expression12 ;
 */
	ExpressionOr;

ExpressionOr returns Expression:
/*
 * expression12 : expression11 ( sp OR sp expression11 )* ;
 */
	ExpressionXor ({ExpressionOr.left=current} operator='OR' right=ExpressionXor)*;

ExpressionXor returns Expression:
/*
 * expression11 : expression10 ( sp XOR sp expression10 )* ;
 */
	ExpressionAnd ({ExpressionXor.left=current} operator='XOR' right=ExpressionAnd)*;

ExpressionAnd returns Expression:
/*
 * expression10 : expression9 ( sp AND sp expression9 )* ;	
 */
	ExpressionNot ({ExpressionAnd.left=current} operator='AND' right=ExpressionNot)*;

ExpressionNot returns Expression:
/*
 * expression9 : ( sp NOT sp expression9 )
 *               | expression8;
 */
	(operator='NOT' left=ExpressionNot) | ExpressionComparison;

ExpressionComparison returns Expression:
/*
 * expression8 : expression7 ( ws partialComparisonExpression )* ;
 * 
 * partialComparisonExpression : ( '=' ws expression7 )
 *                             | ( '<>' ws expression7 )
 *                             | ( '!=' ws expression7 )
 *                             | ( '<' ws expression7 )
 *                             | ( '>' ws expression7 )
 *                             | ( '<=' ws expression7 )
 *                             | ( '>=' ws expression7 );
 */
	ExpressionPlusMinus ({ExpressionComparison.left=current} operator=('=' | '<>' | '!=' | '<' | '>' | '<=' | '>=')
	right=ExpressionPlusMinus)*;

ExpressionPlusMinus returns Expression:
/*
 * expression7 : expression6 ( ( ws '+' ws expression6 ) | ( ws '-' ws expression6 ) )* ;
 */
	ExpressionMulDiv ({ExpressionPlusMinus.left=current} operator=('+' | '-') right=ExpressionMulDiv)*;

ExpressionMulDiv returns Expression:
/*
 * expression6 : expression5 ( ( ws '*' ws expression5 ) | ( ws '/' ws expression5 ) | ( ws '%' ws expression5 ) )* ;
 */
	ExpressionPower ({ExpressionMulDiv.left=current} operator=('*' | '/' | '%') right=ExpressionPower)*;

ExpressionPower returns Expression:
/*
 * expression5 : expression4 ( ws '^' ws expression4 )* ;
 */
	ExpressionUnaryPlusMinus ({ExpressionPower.left=current} operator='^' right=ExpressionUnaryPlusMinus)*;

ExpressionUnaryPlusMinus returns Expression:
/*
 * expression4 : expression3
 *            | ( ws '+' ws expression3 )
 *            | ( ws '-' ws expression3 );
 */
	Expression3 | operator='+' left=Expression3 | => operator='-'
	left=Expression3;

Expression3 returns Expression:
/*
 * expression3 : expression2 ( ( ws '[' expression ']' ) | ( ws '[' expression? '..' expression? ']' ) | ( ws '=~' expression2 ) | ( sp IN expression2 ) | ( sp STARTS sp WITH expression2 ) | ( sp ENDS sp WITH expression2 ) | ( sp CONTAINS expression2 ) | ( sp IS sp NULL ) | ( sp IS sp NOT sp NULL ) )* ;
 */
	ExpressionNodeLabelsAndPropertyLookup (expression3Parts+=Expression3Part)*;

Expression3Part:
	{Index} '[' expression=Expression ('..' upper=Expression)? ']' | {RegExpMatching} ('=~'
	expression=ExpressionNodeLabelsAndPropertyLookup) | {InCollection} ('IN'
	expression=ExpressionNodeLabelsAndPropertyLookup) | {StartsWith} ('STARTS' 'WITH'
	expression=ExpressionNodeLabelsAndPropertyLookup) | {EndsWith} ('ENDS' 'WITH'
	expression=ExpressionNodeLabelsAndPropertyLookup) | {Contains} ('CONTAINS'
	expression=ExpressionNodeLabelsAndPropertyLookup) | {IsNull} ('IS' 'NULL') | {IsNotNull} ('IS' 'NOT' 'NULL');

ExpressionNodeLabelsAndPropertyLookup returns Expression:
/*
 * expression2 : expression1 ( propertyLookup | nodeLabels )* ;
 */
	Expression1 ({ExpressionNodeLabelsAndPropertyLookup.left=current} propertyLookups+=PropertyLookup |
	nodeLabelList+=NodeLabel)*;

	// TODO
/* Expression1 */
Expression1 returns Expression:
/*
 * expression1 : numberLiteral
 *             | StringLiteral
 *             | parameter
 *             | TRUE
 *             | FALSE
 *             | NULL
 *             | caseExpression
 *             | ( COUNT '(' '*' ')' )
 *             | mapLiteral
 *             | listComprehension
 *             | ( '[' ws expression ws ( ',' ws expression ws )* ']' )
 *             | ( FILTER ws '(' ws filterExpression ws ')' )
 *             | ( EXTRACT ws '(' ws filterExpression ws ( ws '|' expression )? ')' )
 *             | reduce
 *             | ( ALL ws '(' ws filterExpression ws ')' )
 *             | ( ANY ws '(' ws filterExpression ws ')' )
 *             | ( NONE ws '(' ws filterExpression ws ')' )
 *             | ( SINGLE ws '(' ws filterExpression ws ')' )
 *             | shortestPathPattern
 *             | relationshipsPattern
 *             | parenthesizedExpression
 *             | functionInvocation
 *             | variable;
 */
	{NumberConstant} value=Number | {StringConstant} value=STRING_LITERAL | Parameter | {BoolConstant} value=('TRUE' |
	'FALSE') | {NullConstant} 'NULL' | {CaseExpression} expression=CaseExpression | {Count} 'COUNT' '(' '*' ')' |
	MapLiteral | ListComprehension | {ExpressionList} ('[' expressions+=Expression (',' expressions+=Expression)* ']') |
	{Filter} 'EXTRACT' '(' filterExpression=FilterExpression ('|' expression=Expression)? ')' | Reduce | {Filter}
	'FILTER' '(' filterExpression=FilterExpression ')' | {All} 'ALL' '(' filterExpression=FilterExpression ')' | {Any}
	'ANY' '(' filterExpression=FilterExpression ')' | {None} 'NONE' '(' filterExpression=FilterExpression ')' | {Single}
	'SINGLE' '(' filterExpression=FilterExpression ')' | ShortestPathPattern | RelationshipsPattern |
	ParenthesizedExpression | FunctionInvocation | {VariableRef} variableRef=[Variable|SYMBOLIC_NAME_STRING_X];

Reduce:
/*
 * reduce : REDUCE ws '(' variable '=' expression ',' idInColl '|' expression ')' ;
 */
	'REDUCE' '(' accumulator=Variable '=' accumulatorExpression=Expression ',' idInColl=IdInColl '|'
	expression=Expression ')';

ParenthesizedExpression:
/*
 * parenthesizedExpression : '(' expression ')' ;
 */
	'(' expression=Expression ')';

RelationshipsPattern:
/*
 * relationshipsPattern : nodePattern ( ws patternElementChain )+ ;
 */
	nodePattern=NodePattern (chain+=PatternElementChain)+;

FilterExpression:
/*
 * filterExpression : idInColl ( ws where )? ;
 */
	idInColl=IdInColl (where=Where)?;

IdInColl:
/*
 * idInColl : variable sp IN sp expression ;
 */
	variable=Variable 'IN' expression=Expression;

FunctionInvocation:
/*
 * functionInvocation : functionName ws '(' ws DISTINCT? ( expression ( ',' expression )* )? ws ')' ;
 */
	functionName=FunctionName '(' distinct?='DISTINCT'? (parameter+=Expression (',' parameter+=Expression)*)? ')';

FunctionName:
/*
 * functionName : symbolicNameString ;
 */
	name=SYMBOLIC_NAME_STRING_X;

ListComprehension:
/*
 * listComprehension : '[' filterExpression ( ws '|' expression )? ']' ;
 */
	'[' filterExpression=FilterExpression ('|' expression=Expression)? ']';

PropertyLookup:
/*
 * propertyLookup : ws '.' ws ( ( propertyKeyName ( '?' | '!' ) ) | propertyKeyName ) ;
 */
	'.' (propertyKeyName=PropertyKeyName propertyOperator=('?' | '!') | propertyKeyName=PropertyKeyName);

CaseExpression:
/*
 * caseExpression : ( ( CASE ( caseAlternatives )+ ) | ( CASE expression ( caseAlternatives )+ ) ) ( ws ELSE expression )? END ;
 */
	(('CASE' (caseAlternatives+=CaseAlternatives)+) | ('CASE' caseExpression=Expression
	(caseAlternatives+=CaseAlternatives)+)) ('ELSE' elseExpression=Expression)? 'END';

CaseAlternatives:
/*
 * caseAlternatives : WHEN expression THEN expression ;
 */
	'WHEN' when=Expression 'THEN' then=Expression;

Variable:
/*
 * variable : symbolicNameString ;
 */
	name=SYMBOLIC_NAME_STRING_X;

/*******************************************/
MapLiteral:
/*
 * mapLiteral : '{' ws ( propertyKeyName ws ':' ws expression ws ( ',' ws propertyKeyName ws ':' ws expression ws )* )? '}' ;
 */
	{MapLiteral} '{' (entries+=MapLiteralEntry (',' entries+=MapLiteralEntry)*)? '}';

MapLiteralEntry:
	key=PropertyKeyName ':' value=Expression;

Parameter:
/*
 * parameter : '{' ws ( symbolicNameString | unsignedDecimalInteger ) ws '}' ;
 */
// TODO: CHECK - Number (positive Integer)
	'{' parameter=(SYMBOLIC_NAME_STRING | Number) '}';

PropertyExpression:
/*
 * propertyExpression : expression1 ( ws propertyLookup )+ ;
 */
	Expression1 (propertyLoopup+=PropertyLookup)+;

	//BulkImportQuery:
//LoadCSVQuery:
//		// TODO clause
//	LoadCSV /* ( ws clause )* */;
//
//PeriodicCommitHint:
//	{PeriodicCommitHint} 'USING' 'PERIODIC' 'COMMIT' (count=SignedIntegerLiteral)?;
LoadCSVWithHeaders:
	'WITH' 'HEADERS';

PropertyKeyName:
	SYMBOLIC_NAME_STRING;

LeftArrowHead:
// TODO!
	'<';

RightArrowHead:
// TODO!
	'>';

Dash:
// TODO!
	'-';

Number hidden():
// TODO CHECK NUMBER!
	HEX | (INT | DECIMAL) ('.' (INT | DECIMAL))?;

SYMBOLIC_NAME_STRING_X:
/*
 * symbolicNameString : UnescapedSymbolicNameString
 *                  | EscapedSymbolicNameString
 *                  | CYPHER
 *                  | EXPLAIN
 *                  | PROFILE
 *                  | USING
 *                  | PERIODIC
 *                  | COMMIT
 *                  | UNION
 *                  | ALL
 *                  | CREATE
 *                  | INDEX
 *                  | ON
 *                  | DROP
 *                  | CONSTRAINT
 *                  | ASSERT
 *                  | IS
 *                  | UNIQUE
 *                  | EXISTS
 *                  | LOAD
 *                  | CSV
 *                  | WITH
 *                  | HEADERS
 *                  | FROM
 *                  | AS
 *                  | FIELDTERMINATOR
 *                  | OPTIONAL
 *                  | MATCH
 *                  | UNWIND
 *                  | MERGE
 *                  | SET
 *                  | DELETE
 *                  | DETACH
 *                  | REMOVE
 *                  | FOREACH
 *                  | IN
 *                  | DISTINCT
 *                  | RETURN
 *                  | ORDER
 *                  | BY
 *                  | L_SKIP
 *                  | LIMIT
 *                  | DESCENDING
 *                  | DESC
 *                  | ASCENDING
 *                  | ASC
 *                  | JOIN
 *                  | SCAN
 *                  | START
 *                  | NODE
 *                  | RELATIONSHIP
 *                  | REL
 *                  | WHERE
 *                  | SHORTESTPATH
 *                  | ALLSHORTESTPATHS
 *                  | OR
 *                  | XOR
 *                  | AND
 *                  | NOT
 *                  | STARTS
 *                  | ENDS
 *                  | CONTAINS
 *                  | NULL
 *                  | TRUE
 *                  | FALSE
 *                  | COUNT
 *                  | FILTER
 *                  | EXTRACT
 *                  | ANY
 *                  | NONE
 *                  | SINGLE
 *                  | REDUCE
 *                  | CASE
 *                  | ELSE
 *                  | END
 *                  | WHEN
 *                  | THEN
 *                  | L_0X
 *                   ;
 */
	SYMBOLIC_NAME_STRING | 'CYPHER' | 'EXPLAIN' | 'PROFILE' | 'USING' | 'PERIODIC' | 'COMMIT' | 'UNION' | 'ALL' |
	'CREATE' | 'INDEX' | 'ON' | 'DROP' | 'CONSTRAINT' | 'ASSERT' | 'IS' | 'UNIQUE' | 'EXISTS' | 'LOAD' | 'CSV' | 'WITH' |
	'HEADERS' | 'FROM' | 'AS' | 'FIELDTERMINATOR' | 'OPTIONAL' | 'MATCH' | 'UNWIND' | 'MERGE' | 'SET' | 'DELETE' |
	'DETACH' | 'REMOVE' | 'FOREACH' | 'IN' | 'DISTINCT' | 'RETURN' | 'ORDER' | 'BY' | 'SKIP' | 'LIMIT' | 'DESCENDING' |
	'DESC' | 'ASCENDING' | 'ASC' | 'JOIN' | 'SCAN' | 'START' | 'NODE' | 'RELATIONSHIP' | 'REL' | 'WHERE' | 'SHORTESTPATH'
	| 'ALLSHORTESTPATHS' | 'OR' | 'XOR' | 'AND' | 'NOT' | 'STARTS' | 'ENDS' | 'CONTAINS' | 'NULL' | 'TRUE' | 'FALSE' | 'COUNT' |
	'FILTER' | 'EXTRACT' | 'ANY' | 'NONE' | 'SINGLE' | 'REDUCE' | 'CASE' | 'ELSE' | 'END' | 'WHEN' | 'THEN';

terminal SYMBOLIC_NAME_STRING:
// TODO!!
	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal ESCAPED_SYMBOLIC_NAME_STRING:
	'`' SYMBOLIC_NAME_STRING '`';

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal STRING_LITERAL:
	'"' ('\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | '"'))* '"' | "'" ('\\' .
	/* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\' | "'"))* "'";

terminal HEX:
	('0x' | '0X') ('0'..'9' | 'A'..'F')+;

terminal INT returns ecore::EInt:
	'0'..'9' ('0'..'9')*;

terminal DECIMAL:
	INT (('e') ('+' | '-')? INT)?;
